import sys
import string

SGN = ("u", "s")
LEN = ("64f", "32f", "16f", "8f", "64", "32", "16", "8", "")
SUPERBIGTYPE_NAME = "unsigned long long"
SUPERBIGTYPE_BITS = 64
SUPERBIGTYPE_SUFFIX = "ULL"

def main (args):
  f = open("bitwork.cpp", "wb")

  f.write("// Generated by make_bitwork.py\n\n" +
          "#include \"header.hpp\"\n" +
          "#include <cstring>\n" +
          "#include <memory>\n" +
          "\n" +
          "using core::numeric_limits;\n" +
          "using core::check;\n" +
          "using core::createBitmask;\n" +
          "using core::extendSign;\n" +
          "using core::sl;\n" +
          "using core::sr;\n" +
          "using core::set;\n" +
          "using core::get;\n" +
          "using std::unique_ptr;\n" +
          "using core::writeIeu;\n" +
          "using core::readIeu;\n" +
          "using core::readValidIeu;\n" +
          "using core::writeIes;\n" +
          "using core::readIes;\n" +
          "using core::readValidIes;\n" +
          "\n" +
          "void testCreateBitmask () {\n")

  def makeLowMask (bits):
    result = ""
    while bits >= 4:
      result = "F" + result
      bits -= 4
    assert bits >= 0
    assert bits < 4
    result = ("0", "1", "3", "7")[bits] + result
    return result.zfill(16)
  f.write("  " + SUPERBIGTYPE_NAME + " bitmasks[] = {" + ", ".join(("0x" + makeLowMask(bits) for bits in xrange(0, SUPERBIGTYPE_BITS + 1))) + "};\n")
  for typeSgn in SGN:
    for typeLen in LEN:
      type = "i" + typeSgn + typeLen
      f.write("\n" +
              "  // Test " + type + ".\n" +
              "  {\n" +
              "    for (iu i = 0; i != (numeric_limits<" + type + ">::bits + 1); ++i) {\n" +
              "      check(static_cast<" + type + ">(bitmasks[i]), createBitmask<" + type + ">(i));\n" +
              "    }\n" +
              "  }\n")

  f.write("}\n" +
          "\n" +
          "void testExtendSign () {\n")

  def renderHexInteger (value, minDigits = SUPERBIGTYPE_BITS / 4):
    value = hex(value)[2:].upper()
    if value[-1] == "L":
      value = value[:-1]
    return "0x" + value.zfill(minDigits) + SUPERBIGTYPE_SUFFIX
  def renderSignExtendedHexInteger (value, minDigits = SUPERBIGTYPE_BITS / 4):
    if value == 0:
      return "0x0" + SUPERBIGTYPE_SUFFIX
    value = hex(value)[2:].upper()
    if value[-1] == "L":
      value = value[:-1]
    value = {"1": "F", "2": "E", "3": "F", "4": "C", "5": "D", "6": "E", "7": "F", "8": "8", "9": "9", "A": "A", "B": "B", "C": "C", "D": "D", "E": "E", "F": "F"}[value[0]] + value[1:]
    return "0x" + "F" * (minDigits - len(value)) + value + SUPERBIGTYPE_SUFFIX
  plainValues = ""
  signExtendedValues = ""
  for topBit in xrange(0, SUPERBIGTYPE_BITS):
    vals = [1 << topBit]
    if (topBit - 1) >= 0:
      vals.append((1 << topBit) | (1 << (topBit - 1)))
    if (topBit - 2) >= 0:
      vals.append((1 << topBit) | (1 << (topBit - 2)))
    if (topBit - 2) > 1:
      vals.append((1 << topBit) | (1 << 1))
    if (topBit - 2) > 0:
      vals.append((1 << topBit) | (1 << 0))
    plainValues += "    {" + ", ".join((renderHexInteger(val) for val in vals)) + ", 0,},\n"
    signExtendedValues += "    {" + ", ".join((renderSignExtendedHexInteger(val) for val in vals)) + ", 0,},\n"
  f.write("  " + SUPERBIGTYPE_NAME + " plainValues[][6] = {\n" + plainValues + "  };\n")
  f.write("  " + SUPERBIGTYPE_NAME + " signExtendedValues[][6] = {\n" + signExtendedValues + "  };\n")
  for typeSgn in ("s",):
    for typeLen in LEN:
      type = "i" + typeSgn + typeLen
      f.write("\n" +
              "  // Test " + type + ".\n" +
              "  {\n" +
              "    for (iu i = 0; i != numeric_limits<" + type + ">::bits; ++i) {\n" +
              "      for (size_t j = 0; j <= i; ++j) {\n" +
              "        " + SUPERBIGTYPE_NAME + " *inVals = plainValues[j];\n" +
              "        " + SUPERBIGTYPE_NAME + " *outVals = (j < i ? plainValues : signExtendedValues)[j];\n" +
              "        for (; *inVals != 0; ++inVals, ++outVals) {\n" +
              "          DA(*outVals != 0);\n" +
              "          // DA(static_cast<" + SUPERBIGTYPE_NAME + ">(static_cast<" + type + ">(*inVals)) == *inVals);\n" +
              "          check(static_cast<" + type + ">(*outVals), extendSign<" + type + ">(static_cast<" + type + ">(*inVals), i));\n" +
              "        }\n" +
              "      }\n" +
              "    }\n" +
              "  }\n")

  f.write("}\n" +
          "\n" +
          "void testShifting () {")

  for typeSgn in SGN:
    for typeLen in LEN:
      type = "i" + typeSgn + typeLen
      f.write("\n" +
              "  // Test " + type + ".\n" +
              "  {\n" +
              "    " + type + " values[] = {0, 1, static_cast<" + type + ">(static_cast<" + type + ">(1) << (numeric_limits<" + type + ">::bits - 1)), static_cast<" + type + ">(0b0000000001111111111000000000111111110000000111111000001111000110), static_cast<" + type + ">(0b1111111110000000000111111111000000001111111000000111110000111001)};\n" +
              "    for (" + type + " value : values) {\n")
      if typeSgn != "u":
        f.write("      bool topBitSet = (value >> (numeric_limits<" + type + ">::bits - 1)) & 0b1;\n"
                "\n")
      f.write("      iu i = 0;\n" +
              "      for (; i != numeric_limits<" + type + ">::bits; ++i) {\n" +
              "        check(static_cast<" + type + ">(value << i), sl(value, i));\n")
      if typeSgn == "u":
        f.write("        check(static_cast<" + type + ">(value >> i), sr(value, i));\n")
      else:
        f.write("        auto srValueMask = createBitmask<" + type + ">(numeric_limits<" + type + ">::bits - i);\n" +
                "        check(static_cast<" + type + ">(((value >> i) & srValueMask) | (topBitSet ? ~srValueMask : 0)), sr(value, i));\n")
      f.write("      }\n" +
              "      for (; i != (numeric_limits<" + type + ">::bits + 1); ++i) {\n" +
              "        check(0, sl(value, i));\n")
      if typeSgn == "u":
        f.write("        check(0, sr(value, i));\n")
      else:
        f.write("        check(topBitSet ? createBitmask<" + type + ">(numeric_limits<" + type + ">::bits) : 0, sr(value, i));\n")
      f.write("      }\n" +
              "    }\n" +
              "  }\n")

  f.write("}\n" +
          "\n" +
          "void testSetAndGet () {\n")

  f.write("  iu8f b[" + str(SUPERBIGTYPE_BITS * 3) + "];\n")
  for typeSgn in SGN:
    for typeLen in LEN:
      type = "i" + typeSgn + typeLen
      f.write("\n" +
              "  // Test " + type + ".\n" +
              "  {\n" +
              "    " + type + " value = static_cast<" + type + ">(0b1111111110000000000111111111000000001111111000000111110000111001);\n" +
              "    " + type + " valueB = value;\n" +
              "    for (size_t i = 0 ; i != sizeof(b) - sizeof(value); ++i) {\n" +
              "      set(b + i, value);\n" +
              "      check(0, memcmp(&valueB, b + i, sizeof(value)));\n" +
              "      check(value, get<" + type + ">(b + i));\n" +
              "    }\n" +
              "  }\n")

  f.write("}\n" +
          "\n" +
          "void testIex () {\n")

  def makeIeuBytes (value):
    assert value >= 0
    bs = []
    while True:
      bs.append(value & 0x7F)
      value >>= 7
      if value == 0:
        break
    return [(b | 0x80) for b in bs[0:-1]] + bs[-1:]
  def makeIesBytes (value, topBit):
    assert (value >> (topBit + 1)) == 0
    if ((value >> topBit) & 0b1) == 0:
      isNegative = 0
      bs = makeIeuBytes(value)
    else:
      isNegative = 1
      bs = makeIeuBytes(~value + 1 + (1 << (topBit + 1)))
    if (bs[-1] & 0x40) != 0:
      bs[-1] |= 0x80
      bs.append(0x00)
    bs[-1] |= isNegative << 6
    return bs
  def genValues ():
    def add (s, *vs):
      for v in vs:
        s.add(v)
    values = set()
    for b in xrange(1, SUPERBIGTYPE_BITS):
      v = 1 << b
      add(values, v - 2, v - 1, v, v + 1, v + 2)
      v += 1 << (b / 3)
      add(values, v - 2, v - 1, v, v + 1, v + 2)
    add(values, 0xFFFFFFFFFFFFFFFE, 0xFFFFFFFFFFFFFFFF)
    r = list(values)
    r.sort()
    return r
  def countBits (v):
    assert v >= 0
    return len(bin(v)) - 2
  f.write("  typedef unique_ptr<iu8f []> upb;\n" +
          "  typedef std::make_signed<" + SUPERBIGTYPE_NAME + ">::type sgnd;\n" +
          "  struct {\n" +
          "    " + SUPERBIGTYPE_NAME + " value;\n" +
          "    sgnd signedValue;\n" +
          "    size_t ieuSize;\n" +
          "    upb ieu;\n" +
          "    size_t positiveIesSize;\n" +
          "    upb positiveIes;\n" +
          "    size_t negativeIesSize;\n" +
          "    upb negativeIes;\n" +
          "  } valueData[] = {\n")
  for value in genValues():
    def r (bs):
      return ", " + str(len(bs)) + ", upb(new iu8f[" + str(len(bs)) + "]{" + ", ".join((renderHexInteger(b, 2) for b in bs)) + "})"
    f.write("    {" + renderHexInteger(value) + ", static_cast<sgnd>(" + renderSignExtendedHexInteger(value) + ")" + r(makeIeuBytes(value)) + r(makeIesBytes(value, SUPERBIGTYPE_BITS + 1)) + r(makeIesBytes(value, countBits(value) - 1)) + "},\n")
  f.write("  };\n")
  for typeSgn in SGN:
    for typeLen in LEN:
      type = "i" + typeSgn + typeLen
      f.write("\n" +
              "  // Test " + type + ".\n" +
              "  {\n" +
              "    for (auto &valueDatum : valueData) {\n" +
              "      auto value = static_cast<" + type + ">(valueDatum.value);\n")
      if typeSgn == "u":
        f.write("      auto iexSize = valueDatum.ieuSize;\n" +
                "      auto iex = valueDatum.ieu.get();\n")
      else:
        f.write("      bool topBitSet = (value & (static_cast<" + type + ">(1) << (numeric_limits<" + type + ">::bits - 1))) != 0;\n" +
                "      auto iexSize = topBitSet ? valueDatum.negativeIesSize : valueDatum.positiveIesSize;\n" +
                "      auto iex = (topBitSet ? valueDatum.negativeIes : valueDatum.positiveIes).get();\n")
      f.write("\n" +
              "      bool inWritingRange = (valueDatum.value & ~createBitmask<" + SUPERBIGTYPE_NAME + ">(numeric_limits<" + type + ">::bits)) == 0;\n" +
              "      if (inWritingRange) {\n" +
              "        iu8f b[16];\n" +
              "        iu8f *bi = b;\n" +
              "        writeIe" + typeSgn + "(bi, value);\n" +
              "        check(iexSize, bi - b);\n" +
              "        check(0, memcmp(iex, b, iexSize));\n" +
              "      }\n" +
              "\n")
      if typeSgn == "u":
        f.write("      bool inReadingRange = valueDatum.value <= numeric_limits<" + type + ">::max();\n" +
                "      DA(inReadingRange == inWritingRange);\n")
      else:
        f.write("      bool inReadingRange = valueDatum.signedValue >= numeric_limits<" + type + ">::min() && valueDatum.signedValue <= numeric_limits<" + type + ">::max();\n")
      f.write("      if (inReadingRange) {\n" +
              "        iu8f *b = iex;\n" +
              "        iu8f *bi = b;\n" +
              "        check(value, readIe" + typeSgn + "<" + type + ">(bi, bi + iexSize));\n" +
              "        check(iexSize, bi - b);\n" +
              "        bi = b;\n" +
              "        check(value, readIe" + typeSgn + "<" + type + ">(bi, bi + iexSize + 1));\n" +
              "        check(iexSize, bi - b);\n" +
              "        try {\n" +
              "          bi = b;\n" +
              "          readIe" + typeSgn + "<" + type + ">(bi, bi + iexSize - 1);\n" +
              "          check(false);\n" +
              "        } catch (...) {\n" +
              "        }\n" +
              "        bi = b;\n" +
              "        check(value, readValidIe" + typeSgn + "<" + type + ">(bi));\n" +
              "        check(iexSize, bi - b);\n" +
              "      } else   if (iex == valueDatum.ieu.get())      {\n" +
              "        try {\n" +
              "          iu8f *bi = iex;\n" +
              "          readIe" + typeSgn + "<" + type + ">(bi, bi + 1000);\n" +
              "          check(false);\n" +
              "        } catch (...) {\n" +
              "        }\n" +
              "      }\n" +
              "    }\n" +
              "  }\n")

  f.write("}\n")
  f.close()

if __name__=="__main__":
  main([arg.decode(sys.stdin.encoding) for arg in sys.argv[1:]])
